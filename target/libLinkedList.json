{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":5398585311305610496,"abi":{"parameters":[{"name":"dummy_input","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9WSXQqFQAiF70wtSEdt9O1upaFp/0voHyKql6aHPhAF4eBR3W+hGqPe1Xe4Nf/XTNAw5xgyErYQLKkAS2oUFUWlC0qUlTVasgiGTBl7MephwRfWOmPTh4dc7QCegf4DM1YvzDjjCz9USdOuoOlJqz4cZ4+76Q0VMdprqQMAAA==","debug_symbols":"5ZJBCoMwEEXvMmsXHXVi6lVKkahRAiGRGAtFvHujaBVaPEC7mz//5cFARqhlObSFMo3tIb+NoG0lvLImpBEuy6rvhJlT74XzkCNmEUhThymhKYJGaQk5C+MHyjnhynLO2A6nX2BM+XUT0yU7h2NK2QrHNBOnZkJ6m5MdRpzuEeA/HBn//pEhlE5prdri+InD+iGcEqWWa2wGUx1a/+y2ZnvfOVvJenByNi1d0L8A","file_map":{"11":{"source":"pub struct Vec<T> {\n    pub(crate) slice: [T],\n}\n// A mutable vector type implemented as a wrapper around immutable slices.\n// A separate type is technically not needed but helps differentiate which operations are mutable.\nimpl<T> Vec<T> {\n    pub fn new() -> Self {\n        Self { slice: &[] }\n    }\n\n    // Create a Vec containing each element from the given slice.\n    // Mutations to the resulting Vec will not affect the original slice.\n    pub fn from_slice(slice: [T]) -> Self {\n        Self { slice }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index\n    /// points beyond the end of the vector.\n    pub fn get(self, index: u32) -> T {\n        self.slice[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        self.slice[index] = value;\n    }\n\n    /// Push a new element to the end of the vector, returning a\n    /// new vector with a length one greater than the\n    /// original unmodified vector.\n    pub fn push(&mut self, elem: T) {\n        self.slice = self.slice.push_back(elem);\n    }\n\n    /// Pop an element from the end of the given vector, returning\n    /// a new vector with a length of one less than the given vector,\n    /// as well as the popped element.\n    /// Panics if the given vector's length is zero.\n    pub fn pop(&mut self) -> T {\n        let (popped_slice, last_elem) = self.slice.pop_back();\n        self.slice = popped_slice;\n        last_elem\n    }\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    pub fn insert(&mut self, index: u32, elem: T) {\n        self.slice = self.slice.insert(index, elem);\n    }\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the removed element\n    pub fn remove(&mut self, index: u32) -> T {\n        let (new_slice, elem) = self.slice.remove(index);\n        self.slice = new_slice;\n        elem\n    }\n\n    /// Returns the number of elements in the vector\n    pub fn len(self) -> u32 {\n        self.slice.len()\n    }\n}\n\nmod tests {\n    use crate::collections::vec::Vec;\n\n    #[test]\n    fn set_updates_values_properly() {\n        let mut vec = Vec { slice: &[0, 0, 0, 0, 0] };\n\n        vec.set(0, 42);\n        assert_eq(vec.slice, &[42, 0, 0, 0, 0]);\n\n        vec.set(1, 43);\n        assert_eq(vec.slice, &[42, 43, 0, 0, 0]);\n\n        vec.set(2, 44);\n        assert_eq(vec.slice, &[42, 43, 44, 0, 0]);\n\n        vec.set(1, 10);\n        assert_eq(vec.slice, &[42, 10, 44, 0, 0]);\n\n        vec.set(0, 0);\n        assert_eq(vec.slice, &[0, 10, 44, 0, 0]);\n    }\n\n    #[test(should_fail)]\n    fn panics_when_writing_elements_past_end_of_vec() {\n        let mut vec = Vec::new();\n        vec.set(0, 42);\n\n        // Need to use println to avoid DIE removing the write operation.\n        crate::println(vec.get(0));\n    }\n}\n","path":"std/collections/vec.nr"},"64":{"source":"use dep::std::{self, collections::map::HashMap};\nuse std::hash::{poseidon2::Poseidon2Hasher, BuildHasherDefault};\n\npub struct Node<T>{\n    value : T,//value to store in the node \n    prev: Option<Field>, //index of previous node \n    next :Option<Field> //index of next node \n}\n\nimpl<T> Node<T> {\n    pub fn new(value: T) -> Self {\n        Node {\n            value,\n            prev: Option::none(),\n            next: Option::none()\n        }\n    }\n}\n\n/// A doubly-linked list implementation using HashMap for node storage.\n/// Supports operations at both ends in constant time.\npub struct LinkedList<T, let L:u32>{\n    nodes:HashMap<Field, Node<T>, L, BuildHasherDefault<Poseidon2Hasher>>, //HashMap<Field, Node<T>, N, BuildHasherDefault<Poseidon2Hasher>>,\n    head: Option<Field>,\n    tail: Option<Field>,\n    size: u32,\n    next_key: Field,\n    free_keys: Vec<Field> \n}\n\n\nimpl<T,let L:u32> LinkedList<T,L>{\n    \n    pub fn new_map() -> HashMap<Field, Node<T>, L, BuildHasherDefault<Poseidon2Hasher>> {\n        let mut map: HashMap<Field, Node<T>,L, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n        map\n    }\n\n    pub fn new() -> Self {\n        LinkedList {\n            nodes: Self::new_map(),\n            head: Option::none(),\n            tail: Option::none(),\n            size: 0,\n            next_key: 0,\n            free_keys: Vec::new(),  \n        }\n    }\n    \n    // Add a value to the front of the list \n    fn push_front(&mut self, value: T){\n        let key = self.allocate_node(value);\n        self.push_front_node(key);\n    }\n\n    /// Add a value to the back of the list\n    fn push_back(&mut self, value: T) {\n        let key = self.allocate_node(value);\n        self.push_back_node(key);\n    }\n\n    fn pop_front(&mut self) -> Option<T>{\n        let front_key = self.pop_front_node();\n        assert(front_key.is_some(), \"Expected front_key to be Some, but it was None\");\n\n        let key = front_key.unwrap();\n        self.deallocate_node(key)\n    }\n\n    fn pop_back(&mut self) -> Option<T> {\n        let back_key = self.pop_back_node();\n        assert(back_key.is_some(), \"Expected back_key to be Some, but it was None\");\n        let key = back_key.unwrap();\n        self.deallocate_node(key)\n    }\n    \n    //Stores the given value into Node and connect key to this node \n    fn allocate_node(&mut self, value: T) -> Field {\n        assert(self.size < L, \"LinkedList is full\");\n        \n        let node = Node::new(value);\n        let mut key =0;\n      \n        if self.free_keys.len() > 0 {\n            key = self.free_keys.pop();\n        } else {\n            key = self.next_key;\n            self.next_key += 1;\n        }\n\n        self.nodes.insert(key, node);\n        key\n    }\n\n    fn deallocate_node(&mut self, key: Field) -> Option<T> {     \n        assert(self.nodes.contains_key(key), \"Node does not exist\");\n        // Clear node connections\n        {\n            let mut node = self.nodes.get(key).unwrap();\n            node.next = Option::none();\n            node.prev = Option::none();\n            self.nodes.insert(key, node);\n        }\n\n        // Get node's value before removing it\n        let value = {\n            let node = self.nodes.get(key).unwrap();\n            node.value\n        };\n\n        // Remove node from nodes hashmap and recycle key\n        self.nodes.remove(key);\n        self.free_keys.push(key);\n\n        Option::some(value)\n    }\n\n    //Adds the given node to the front of the list \n    //Case 1: if the list is empty , this node will be both the head and the tail\n    //Case 2: if not , we update both status of new node and original head_node \n    fn push_front_node(&mut self, key: Field){\n        \n        //ensure the corresponding node does exist\n        assert(self.nodes.contains_key(key), \"Node does not exist\");\n\n        //update new node status \n        {\n            let mut node = self.nodes.get(key).unwrap();\n            node.next = self.head;\n            node.prev = Option::none();\n            self.nodes.insert(key,node);\n        }\n        //if this list is empty\n        //we set this node to be both the head and tail of this list \n        if self.head.is_none() {\n            self.head = Option::some(key);\n            self.tail = Option::some(key);\n        } else {\n            //if this list is not empty , \n            //we update the pointer prev to the original head node\n            let head_key = self.head.unwrap();\n            let mut head_node = self.nodes.get(head_key).unwrap();\n            head_node.prev = Option::some(key);\n            self.head = Option::some(key);\n            self.nodes.insert(head_key,head_node);\n        }\n\n        //both case will increase the list size \n        self.size += 1 ;\n        \n    \n    }\n\n    /// Adds the given node to the back of the list\n    /// Case 1: if the list is empty, this node will be both the head and tail\n    /// Case 2: if not, we update both the status of new node and original tail_node\n    fn push_back_node(&mut self, key: Field) {\n        // Ensure the corresponding node does exist\n        assert(self.nodes.contains_key(key), \"Node does not exist\");\n\n        //Update new node status \n        {\n            let mut node = self.nodes.get(key).unwrap();\n            node.prev = self.tail;\n            node.next = Option::none();\n            self.nodes.insert(key, node);\n        }\n        \n\n        // If this list is empty\n        // We set this node to be both the head and tail of this list\n        if self.tail.is_none() {\n            self.head = Option::some(key);\n            self.tail = Option::some(key);\n        } else {\n        // If this list is not empty\n        // We update the pointer next of the original tail node\n            let tail_key = self.tail.unwrap();\n            let mut tail_node = self.nodes.get(tail_key).unwrap();\n            tail_node.next = Option::some(key);\n            self.tail = Option::some(key);\n            self.nodes.insert(tail_key, tail_node);\n        }\n\n        // Both cases will increase the list size\n        self.size += 1;\n        \n    }\n    \n    //Remove the node at the front of the list \n    // Case 1: if the list is empty , will return None  \n    // Case 2: \n    fn pop_front_node(&mut self) -> Option<Field> {\n       //if the list is empty , return None \n       let result = if self.head.is_none(){\n            Option::none() \n       }else {\n            let (head_key,next_key) = {\n            let head_key  =  self.head.unwrap();\n            let head_node =  self.nodes.get(head_key).unwrap();\n            (head_key,head_node.next)\n            };\n\n            //If this head_node is the only one in this list \n            //We can continue with it , as the type of head_node is wrapped in Option \n            //Means it will be None in this case \n            self.head = next_key;\n            \n            //if the list becomes empty after removal \n            //else we update new head_node information \n            if self.head.is_none(){\n                self.tail = Option::none();\n            } else {\n                let new_head_key = self.head.unwrap();\n                let mut new_head_node = self.nodes.get(new_head_key).unwrap();\n                new_head_node.prev = Option::none();\n                self.nodes.insert(new_head_key,new_head_node);\n            }\n\n            //after update all those , we decrease the size of list by 1\n            self.size -= 1;\n            //Return the removed node key \n            Option::some(head_key)\n       };\n\n            result\n    }\n\n    fn pop_back_node(&mut self) -> Option<Field> {\n        // if the list is empty , return None \n        let result = if self.tail.is_none(){\n            Option::none()\n        } else{\n            // if the tail of list is existed\n            // get the tail key and previous node key \n            let (tail_key,prev_key) = {\n                let tail_key = self.tail.unwrap();\n                let tail_node = self.nodes.get(tail_key).unwrap();\n                (tail_key,tail_node.prev)\n            };\n            // after pop out the original tail , the prev_key should be the tail\n            self.tail = prev_key ;\n            // if the list becomes empty after removal , return None \n            // otherwise we update the info of new tail node \n            let new_tail_key  = self.tail.unwrap();\n            let mut new_tail_node = self.nodes.get(new_tail_key).unwrap();\n            new_tail_node.next = Option::none();\n            self.nodes.insert(new_tail_key,new_tail_node);  \n             // Decrease the list size by 1 \n            self.size -= 1 ;\n            // Return the removed node key\n            Option::some(tail_key) \n        \n        };\n\n        result    \n    } \n\n    \n    \n}\n\n\n\npub fn test_linked_list() {\n    let mut list: LinkedList<u32, 10> = LinkedList::new();\n\n    // Test push_front\n    list.push_front(1);\n    list.push_front(2);\n    assert(list.size == 2, \"Size should be 2 after two push_front operations\");\n    assert(list.head.is_some(), \"Head should not be None\");\n    assert(list.tail.is_some(), \"Tail should not be None\");\n\n    // Test push_back\n    list.push_back(3);\n    assert(list.size == 3, \"Size should be 3 after push_back operation\");\n\n    // // Test pop_front\n    // let front = list.pop_front();\n    // assert( front.unwrap() == 2, \"pop_front should return 2\");\n    // assert(list.size == 2, \"Size should be 2 after pop_front operation\");\n\n    // // Test pop_back\n    // let back = list.pop_back();\n    // assert(back.is_some() && back.unwrap() == 3, \"pop_back should return 3\");\n    // assert(list.size == 1, \"Size should be 1 after pop_back operation\");\n\n    // // Test pop_front on single-element list\n    // let front = list.pop_front();\n    // assert(front.is_some() && front.unwrap() == 1, \"pop_front should return 1\");\n    // assert(list.size == 0, \"Size should be 0 after popping all elements\");\n\n    // // Test pop_front on empty list\n    // let front = list.pop_front();\n    // assert(front.is_none(), \"pop_front on empty list should return None\");\n\n    // // Test pop_back on empty list\n    // let back = list.pop_back();\n    // assert(back.is_none(), \"pop_back on empty list should return None\");\n\n    // println(\"All tests passed!\");\n}","path":"/Users/karlyu/libLinkedList/src/linked_list.nr"},"65":{"source":"mod linked_list;\n//use dep::std;\n\nuse linked_list::test_linked_list;\n\nfn main(dummy_input: Field) -> pub Field {\n    test_linked_list();\n\n    dummy_input\n}\n\n","path":"/Users/karlyu/libLinkedList/src/main.nr"}},"names":["main"],"brillig_names":[]}