{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":429873117455430860,"abi":{"parameters":[{"name":"dummy_input","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"50837112298936201":{"error_kind":"string","string":"Size should be 2 after pop_front operation"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5580628204509289529":{"error_kind":"string","string":"Size should be 0 after popping all elements"},"5874699590226855626":{"error_kind":"string","string":"Size should be 1 after pop_back operation"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9WYzWrbQBDH17b8ISdO7KSJT4GcSikU9C35Zmi+E+c7t0KxYxl6KSX0AXxq6aGX5Fb6ED30GUrpGxTaN2mhVryjjNa7pOAdcAbEStq/fjOe/dBYOTa2/OgoM7W1eetagefFoRPbrt21nFYv8i3P7wWRHdl+5PedyHXjyIvCVq8VWi3bc2N74LfcgTU2zMxpZuc1spLYCjzGhLtOlJd4MDbKnBvsbozvG19rOrOTfDVIfXg2DTe4fFhcx6Lhhh5RHnyieN2HlQeqeMnmAxE3IFrHZPOBiEu1LgKi+etMjNut5QUnOgoFPQGPX0qaWLeFAbxQc5I85FBrSPo/NP/crHz+Ks3d87+/tr9cv3uC+wq8/fHt0+/H6+9PcB/wWy86P7+/vOqIMdzw1hT8QHHT5tfWdGabbPK36+JHlh+YLGua43dNxNTPtx3gGzTxW1C4bwyzfCb4LQg68Rms2USaTaTB7C2k2VJotpFmW6HZQZodhWYXaXYVmj2k2VNo9pFmX6E5QJoDhaaDNB2F5hBpDhWaI6Q5UmiOkeZYoTlBmhOF5hRpThWaM6Q5U2jOkeZcoblAmgtBU0PnYBtcA2uFYq+KRm8g2rVo2zUhDwz9TvBdpPHt5AR/jGX3ASb4rzLKfW/83sX+IB4xPzDWNdAM7+IR+4zh5O+AviLqg/GtjI6nSCebW6Dz0XnAz2HMKN9tVPM9sWVJ/NhXYuUhSw3yUUD3IK+Q5wrWC30m6jOGWT9Vfm0gP5gFcRQFPVSyi7wtoWfg+brEf0nwn4lbck/MiynRmxJ9aXQ84+dz/Ejm0Ed4hk2uM301adiX7Wn6+EEk27f08Z1L4Jdo8uMBv0yTn5RfoeH3gG+S8N0Q+FWa+NN37hwNP41/nmb+pP8PajTxx8BfIOE76f+PRZr5YwO/TpOfdH9o0Ixvmp8lmvx0gb9Mk58W8B/R5KcHddMKuzOxpl1F9zXWtPH/1rTgvyrESlXTrgrxiPnBdWvS15TEWpf0iWPYlPhpSvzIWAsaWRWNrGWNrJpGVlkjS2ful2Y0rnmNrJJGVkMja1bn6pxGls45UZzRuOoaWVWNrFmdEzrXo6GRNav76qJGlqmRlX63EK5zvG3z1prSIFZDEmteEivoZd8GZXXUPNK+uXr1+i0TDDsGOD6H/oYigDXh+YKCK/LxdeOe/jUJK1m0MODGMOu/ze9bU1gYjQcnMfhYV2TZD7BM8F8U9Nf8Gm980BpTxDkIu/bA7Q66frff9y67SwI/sTzK0z9Ymm7CriYAAA==","debug_symbols":"5ZjdiuMwDIXfxde5iGTHkvoqyzD0JzMEQlrSdmEpefd1hma7tEOXo17uXZ3oyHa/rxR0Cbt2c/5874aP/TGsflxCv9+uT91+KKtLqL8eHQ/rYV4dT+vxFFZU11Voh135RDpV4aPr27DKaaoeSlWa5lqrku1WHKe3KtCr3fXWXbP+3f2xmGuhazHXRs+LU8r5WpyS8j+KiWwpphjvLsn/wyXjq5c04eWSpvmue3qxu3ETr7XGWe66N692j7yc3WJTP/8aTZaTlB2aP7Wxnt7KYjN2fd99vt//Bi+h+faUT7qVe2U8InhE8YjBkVzjEcIjjEciHkl4BKefcfoZp59x+hmnLzh9wekLTl9w+oLTF5y+4PQFpy84fcHpK05fcfqK01ecvuL0FaevOH3F6StOX3H6htM3nL7h9A2nbzh9w+kbTt9w+obTN5x+eeTIkCPDjkx0ZJIj0zgy2ZERR0YdGYcH5PCAHB6QwwNyeEAOD8jhATk8IIcH5PCAHB6wwwN2eMAOD9jhATs8YIcH7PCAHR6wwwN2eBAdHkSHB9HhQXR4EB0eRIcH8VsPlHWZvmR6iAgeUTxiWGQqq5/rsVtv+nYek8wvz8N2mZqU5enXYXmzzFUO437b7s5jO09YbsOVmVfiquGvf6eyoEQVpVw2KRv9Bg==","file_map":{"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"63":{"source":"use dep::std::{self, collections::map::HashMap};\nuse std::hash::{poseidon2::Poseidon2Hasher, BuildHasherDefault};\n\npub struct Node<T>{\n    value : T,//value to store in the node \n    prev: Option<Field>, //index of previous node \n    next :Option<Field> //index of next node \n}\n\nimpl<T> Node<T> {\n    pub fn new(value: T) -> Self {\n        Node {\n            value,\n            prev: Option::none(),\n            next: Option::none()\n        }\n    }\n}\n\n/// A doubly-linked list implementation using HashMap for node storage.\n/// Supports operations at both ends in constant time.\npub struct LinkedList<T, let L:u32>{\n    nodes:HashMap<Field, Node<T>, L, BuildHasherDefault<Poseidon2Hasher>>, \n    head: Option<Field>,\n    tail: Option<Field>,\n    size: u32,\n    next_key: Field,\n}\n\n\nimpl<T,let L:u32> LinkedList<T,L>{\n    \n    pub fn new_map() -> HashMap<Field, Node<T>, L, BuildHasherDefault<Poseidon2Hasher>> {\n        let mut map: HashMap<Field, Node<T>,L, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n        map\n    }\n\n    pub fn new() -> Self {\n        LinkedList {\n            nodes: Self::new_map(),\n            head: Option::none(),\n            tail: Option::none(),\n            size: 0,\n            next_key: 0,\n        }\n    }\n    \n    // Add a value to the front of the list \n    fn push_front(&mut self, value: T){\n        let key = self.allocate_node(value);\n        self.push_front_node(key);\n    }\n\n    /// Add a value to the back of the list\n    fn push_back(&mut self, value: T) {\n        let key = self.allocate_node(value);\n        self.push_back_node(key);\n    }\n\n    fn pop_front(&mut self) -> Option<T>{\n        let front_key = self.pop_front_node();\n        assert(front_key.is_some(), \"Expected front_key to be Some, but it was None\");\n\n        let key = front_key.unwrap();\n        self.deallocate_node(key)\n    }\n\n    fn pop_back(&mut self) -> Option<T> {\n        let back_key = self.pop_back_node();\n        assert(back_key.is_some(), \"Expected back_key to be Some, but it was None\");\n        let key = back_key.unwrap();\n        self.deallocate_node(key)\n    }\n    \n    fn allocate_node(&mut self, value: T) -> Field {\n        assert(self.size < L, \"LinkedList is full\");\n        \n        let node = Node::new(value);\n        \n        let key = self.next_key;\n        self.next_key += 1;\n        \n        self.nodes.insert(key, node);\n        key\n    }\n\n    //This function deals with update pointers between nodes \n    fn unlink_node(&mut self, key: Field) {\n        assert(self.nodes.contains_key(key), \"Node does not exist\");\n        \n        //Get the node to unlink \n        let node = self.nodes.get(key).unwrap();\n        let prev_key = node.prev;\n        let next_key = node.next;\n\n        //If this node has prev node , we set the prev_node's next to be \n        //this current node's next , and then update the connection info \n        //otherwise , this node is head node ,\n        //we should set this node's next to be the head node \n        if prev_key.is_some() {\n            let prev = prev_key.unwrap();\n            let mut prev_node = self.nodes.get(prev).unwrap();\n            prev_node.next = next_key;\n            self.nodes.insert(prev, prev_node);\n        } else {\n            //In this case , we don't need to update the nodes hashmap,\n            //as we didn't update the internal status of any node \n            self.head = next_key;\n        }\n\n        //If this node has any next node , we set prev_key of this current node \n        //to be the prev of next node , and update connection info of next node \n        //Otherwise , this current node is the tail node of list \n        //We should set the prev node to be the tail node \n        if next_key.is_some() {\n            let next = next_key.unwrap();\n            let mut next_node = self.nodes.get(next).unwrap();\n            next_node.prev = prev_key;\n            self.nodes.insert(next, next_node);\n        } else {\n            // This node is the tail node\n            self.tail = prev_key;\n        }\n\n        //After update node connections , we need to decrement the list size by 1\n        self.size -= 1;\n\n    }\n\n    //This function is mainly for remove the key from nodes hashmap \n    //And return the value stored in the removed node for us \n    fn deallocate_node(&mut self, key: Field) -> Option<T> {     \n        assert(self.nodes.contains_key(key), \"Node does not exist\");\n       \n        //Unlink the node from the list \n        self.unlink_node(key);\n        \n        // Get node's value before removing it\n        let value = {\n            let node = self.nodes.get(key).unwrap();\n            node.value\n        };\n\n        // Remove node from nodes hashmap \n        self.nodes.remove(key);\n\n        Option::some(value)\n    }\n\n    //Adds the given node to the front of the list \n    fn push_front_node(&mut self, key: Field){\n        \n        //ensure the corresponding node does exist\n        assert(self.nodes.contains_key(key), \"Node does not exist\");\n\n        //update new node status \n        {\n            let mut node = self.nodes.get(key).unwrap();\n            node.next = self.head;\n            node.prev = Option::none();\n            self.nodes.insert(key,node);\n        }\n        //if this list is empty\n        //we set this node to be both the head and tail of this list \n        if self.head.is_none() {\n            self.head = Option::some(key);\n            self.tail = Option::some(key);\n        } else {\n            let old_head_key = self.head.unwrap();\n            //update old head key's prev pointer \n            {\n                let mut old_head_node =self.nodes.get(old_head_key).unwrap();\n                old_head_node.prev = Option::some(key);\n                self.nodes.insert(old_head_key,old_head_node);\n            }\n            //update head pointer to new node key \n            self.head = Option::some(key);\n        }\n\n        //both case will increase the list size \n        self.size += 1 ;\n    }\n\n    /// Adds the given node to the back of the list\n    fn push_back_node(&mut self, key: Field) {\n        // Ensure the corresponding node does exist\n        assert(self.nodes.contains_key(key), \"Node does not exist\");\n\n        //Update new node status \n        {\n            let mut node = self.nodes.get(key).unwrap();\n            node.prev = self.tail;\n            node.next = Option::none();\n            self.nodes.insert(key, node);\n        }\n        \n\n        // If this list is empty\n        // We set this node to be both the head and tail of this list\n        if self.tail.is_none() {\n            self.head = Option::some(key);\n            self.tail = Option::some(key);\n        } else {\n        // If this list is not empty\n        // We update the pointer next of the original tail node\n            let tail_key = self.tail.unwrap();\n            let mut tail_node = self.nodes.get(tail_key).unwrap();\n            tail_node.next = Option::some(key);\n            self.tail = Option::some(key);\n            self.nodes.insert(tail_key, tail_node);\n        }\n\n        // Both cases will increase the list size\n        self.size += 1;\n        \n    }\n    \n    //Remove the node at the front of the list and return the key of removed node \n    fn pop_front_node(&mut self) -> Option<Field> {\n       //if the list is empty , return None \n       let result = if self.head.is_none(){\n            Option::none() \n       }else {\n           let head_key = self.head.unwrap();\n           self.unlink_node(head_key);\n           Option::some(head_key)\n       };\n        result\n    }\n\n    fn pop_back_node(&mut self) -> Option<Field> {\n        // if the list is empty , return None \n        let result = if self.tail.is_none(){\n            Option::none()\n        } else{\n            // Get the tail key that will be returned\n            let tail_key = self.tail.unwrap();\n            // Unlink the tail node\n            self.unlink_node(tail_key);\n            // Return the key of the removed node\n            Option::some(tail_key)\n        \n        };\n        result    \n    } \n}\n\n\n#[test]\npub fn test_linked_list() {\n    let mut list: LinkedList<u32, 10> = LinkedList::new();\n\n    // Test push_front\n    list.push_front(1);\n    assert(list.size == 1, \"Size should be 1 after one push_front operations\");\n    list.push_front(2);\n    // assert(list.size == 2, \"Size should be 2 after one push_front operations\");\n    \n    assert(list.head.is_some(), \"Head should not be None\");\n    assert(list.tail.is_some(), \"Tail should not be None\");\n\n    // Test push_back\n    list.push_back(3);\n    assert(list.size == 3, \"Size should be 3 after push_back operation\");\n\n    // Test pop_front\n    let front = list.pop_front();\n    assert( front.unwrap() == 2, \"pop_front should return 2\");\n    assert(list.size == 2, \"Size should be 2 after pop_front operation\");\n\n    // Test pop_back\n    let back = list.pop_back();\n    assert(back.is_some() , \"pop_back should return 3\");\n    assert(back.unwrap() == 3);\n    assert(list.size == 1, \"Size should be 1 after pop_back operation\");\n\n    // Test pop_front on single-element list\n    let front = list.pop_front();\n    assert(front.is_some() , \"pop_front should return something\");\n    assert(front.unwrap() == 1,\"pop_front should return 1\");\n    assert(list.size == 0, \"Size should be 0 after popping all elements\");\n\n    println(\"All tests passed!\");\n}","path":"/Users/karlyu/libLinkedList/src/linked_list.nr"},"64":{"source":"mod linked_list;\nuse linked_list::test_linked_list;\n\nfn main(dummy_input: Field) -> pub Field {\n    test_linked_list();\n    dummy_input\n}\n\n","path":"/Users/karlyu/libLinkedList/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained"]}